Rules -> Rule Rules | EPSILON
Rule -> Axiom NTerm NTermRule
Axiom -> * | EPSILON
NTerm -> ID
NTermRule -> ( ArgOR ) NTermRuleTail
NTermRuleTail -> ( ArgOR ) NTermRuleTail | EPSILON
ArgOR -> SymArgOR ArgOR | EPSILON
SymArgOR -> STR | NTerm



E -> T E'
E' -> + T E' | EPSILON
T -> F T'
T' -> * F T' | EPSILON
F -> n | ( E )




/* Грамматика входного языка на самом входном языке: */
* Rules (Rule Rules) ()
Rule (Axiom NTerm NTermRule)
Axiom ("*") ()
NTerm ("i")
NTermRule ("(" ArgOR ")" NTermRuleTail)
NTermRuleTail ("(" ArgOR ")" NTermRuleTail) ()
ArgOR (SymArgOR ArgOR) ()
SymArgOR ("s") (NTerm)




enum NON_TERMS {
    NON_TERM_Rules = 256,
    NON_TERM_Rule,
    NON_TERM_Axiom,
    NON_TERM_NTerm,
    NON_TERM_NTermRule,
    NON_TERM_ArgOR,
    NON_TERM_SymArgOR,
};

const std::vector<std::vector<int>> rules {
    {NON_TERM_Rule, NON_TERM_Rules},
    {NON_TERM_Axiom, NON_TERM_NTerm, NON_TERM_NTermRule},
    {'*'},
    {},
    {'i'},
    {'(', NON_TERM_ArgOR, ')'},
    {NON_TERM_SymArgOR, NON_TERM_ArgOR},
    {'s', NON_TERM_NTerm},
};

... table {
        {NON_TERM_Rules {
            {'i', rules[0]},
            {'*', rules[0]}
        }
    }
}

STR и ID это токены лексера


1) Rules -> Rule Rules
2) Rules -> EPSILON
3) Rule -> Axiom NTerm NTermRule 
4) Axiom -> *
5) Axiom -> EPSILON
6) NTerm -> id
7) NTermRule -> ( ArgOR ) NTermRuleTail
8) NTermRuleTail -> ( ArgOR ) 
9) NTermRuleTail -> EPSILON
10) ArgOR -> SymArgOR ArgOR 
11) ArgOR -> EPSILON
12) SymArgOR -> str 
13) SymArgOR -> NTerm


====================================

FIRST
Rules: * ID nil
Rule: * ID
Axiom: * nil
NTerm: ID
NTermRule: (
NTermRuleTail: ( nil
ArgOR: STR ID nil
SymArgOR: STR ID


FOLLOW
Rules: $
Rule: * id $
Axiom: ID
NTerm: ( ) STR ID
NTermRule: * id $
NTermRuleTail: * id $
ArgOR: )
SymArgOR: STR ID )


=====================================







http://hackingoff.com/compilers/predict-first-follow-set







append(xs : [(int, int)], 
       ys : [(int,
              int)]) : [(int, int)] =
  if null(xs) then
    ys
  else
    cons(car(xs), append(cdr(xs),
                         -- параметр не меняется
                         ys);

















